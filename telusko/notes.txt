javacode -> compiler(javac)->byte code(.class)->JVM 
needs a main file


int -4 bytes
long 8bytes
short 2 bytes
float - 4 bytes 7 precision
double -8 bytes
char- 2 bytes
1 byte -8 bits
byte -2^7 to 2^7-1=>-128 to 127

byte by = 127;
float d = 5.8f;
boolean b = true;
double d = 5.8;
long l = 58541l; l is important

int num1 = 0x7E;==>126

int a = 257;//257%256
byte k =(byte) a;
System.out.println(k);

____________________________
bit wise operators

a = 5 0101
b = 7 0111

a | b = 7 0111

a & b = 0101 5

a ^ b = 2 0010

~a = (2's compliment of a is -6)

__________________________________

hexadecimal notation 0x
0-9 a(10)-f(15)
0x0f = 15

binary notation 0b oB 
0b1010 =>1010 in decimal

octal notaion 0
012 => 10

scientific notaion xEy
1.5e3 = 1.5*10^3 = 1500

__________________________________

signed right shift >>
Use Case: Commonly used for arithmetic shifts, especially when you want to divide a number by a power of two while preserving the sign.
int x = -8;  // Binary: 11111111111111111111111111111000
int result = x >> 2;  // Shifts right by 2, result: 11111111111111111111111111111110
System.out.println(result);  // Output: -2


unsigned right shift >>>
Use Case: Useful when you need to perform a logical shift, treating the number as unsigned.
int x = -8;  // Binary: 11111111111111111111111111111000
int result = x >>> 2;  // Shifts right by 2, result: 00111111111111111111111111111110
System.out.println(result);  // Output: 1073741822


signed left shift <<

Use Case: Commonly used to multiply a number by a power of two.
int num = 8;  // Binary: 00000000000000000000000000001000
int result = num << 2;  // Result: 00000000000000000000000000100000 (which is 32)
System.out.println(result);  // Output: 32

__________________________________________________________________________________________

// import java.io.*;
import java.lang.String;
class Hello{
    
    public static void main(String args[]){
       int n = 4;
       switch(n){
        case 1:System.out.println("Monday");
        case 2:System.out.println("Monday");
        case 3:System.out.println("Monday");
        case 4:System.out.println("Four");break;
        case 5:System.out.println("Five");
        default:System.out.println("Five");
       }
       String res="";
        res= n%2==0?"Even":"Odd";
       System.out.println(res);
}

}

_______________________________________________________________________________________________

Objects have properties and behaviours

Calculator calc = new Calculator();
calc is of type Calculator new creates object of type Calculator.

________________________________________________________________________________________________

in Jvm you execute the code
inside jre(java run time environment) we have JVM 
inside jdk we have both

________________________________________________________________________________________________

inside JVM 

we jave stack and heap memory
classes have instance variable
Every method has its own stack
new Object resides in heap memory
instance variable also reside with the object along with its method 

different objects have different storage locations for their method calls and instance variables

if we change instance vairable of one varialbe \\

method overloading means same methods but different amount or type of paramaters

__________________________________________________________________________________________
*****************
(int)(Math.random()*100) for converting double to int

  // int nums[] = {3,7, 2, 4};
        // int nums[] = new int[4];//all the values will be 0
        int nums[][] = new int[3][4];
        for(int n[]: nums){
            for(int m:n){
                System.out.print(m+" ");
            }
            System.out.println();
        }

        int nums[][] = new int[3][]// is called jagged array
        nums[0] = new int[3];
        nums[1] = new int[4];//mentioning the column size
        nums[2] = new int[2];

        //give me one value n from nums array
            for(int n: nums){
                System.out.println(n);
            }

nums.length for length of array


class Student{
    int rollno;
    String name;
    int marks;

}

public class Hello{
    public static void main(String a[]){
     Student s1 = new Student();
     s1.rollno=12;
     s1.name="H2ri";
     s1.marks=32;
     Student s2 = new Student();
     s2.rollno=21;
     s2.name="Krishna";
     s2.marks=42;
     Student s3 = new Student();
     s3.rollno=52;
     s3.name="Krisi";
     s3.marks=52;

      Student students[]= new Student[3];//creating array of refreneces for Student objects
      students[0] = s1;
      students[1] = s2;
      students[2] = s3;

      System.out.println(s1);//Student@2c7b84de

       for(int i = 0;i<students.length;i++){
        System.out.println(students[i].name+": "+students[i].marks);
       }

       for(Student stud: students){
        System.out.println(stud.name+" : "+stud.marks);
       }
      
     }

}

__________________________________________________________________________________________
*****************
String is a class
String name = new String("navin"); pass string to String constructor
name.charAt(0)//gives n
name.concat("reddy")//same as +

java will automatically create object for String name="Hello" syntax;

in heap memory we have String constant pool
String s1 = "Navin";
String s2 = "Navin";
s1 will refer to address of Navin in Scp
got two refreneces for the same object

when concat like Navin +reddy new address is allocated meaning new object 
old Navin is eligible for garbage collection

__________________________________________________________________________________________
************
String buffer and String builder used to make immutable String;

   StringBuffer s = new StringBuffer();//returns 16bytes
        System.out.println(s.capacity());

 s.append(" Reddy");
        
        System.out.println(s);
        String str = s.toString();
        System.out.println(str);//gives Navin reddy

          s.append(" Reddy");
        s.deleteCharAt(2);
        System.out.println(s);
        String str = s.toString();
        System.out.println(str);//give nain reddy

        s.insert(0, "Java ");
        System.out.println(s);

        s.setLength(30);//adds extra characters " "
        s.setLength(2); //prints  only the 2 characters of navin reddy
        s.ensureCapacity(100);//min capacity 100

StringBuffer is thread Safe but StringBuilder is not

__________________________________________________________________________________________

What is static?**************
static variables should be accessed using classname
       Mobile.name = "SmartPhone";

static variable belongs to class not object like data members or instanve variables

class Mobile{
    String brand;int price;
    static String name; // will affect all object .names
    public void show(){
        //inside method are called local variables
        System.out.println(brand);
        System.out.println(price);
        System.out.println(name);
    }
}

//in jvm we have class loader loads class then object are instantiated c will load only once from library
//if we don't create the object nothing will be initialised

in order to get something from static block we can do this

// import java.io.*;
import java.lang.String;

class Mobile{
    String brand;int price;
    static String name; // will affect all object .names

    static{
        //will only once
        name = "Phone";
        System.out.println("Hello");
    }

    public Mobile(){
        brand = "";
        price = 200;
    }
    public void show(){
        //inside method are called local variables
        System.out.println(brand);
        System.out.println(price);
        System.out.println(name);
    }
}

public class Hello{
    public static void main(String a[]) throws ClassNotFoundException{
    //    Mobile  ob1 = new Mobile();
    //    ob1.brand = "Apple";
    //    ob1.price = 1500;
       
    
    //    ob2.show();
    Class.forName("Mobile");

    //gives Hello inside the static block
        
    }

}

__________________________________________________________________________________________

static methods**************
use ClassName.methodName to directly access the class methods
but normal methods need to be called with objects ob.method()

   public static void show1(){
        System.out.println("in static method");
        System.out.println(name);
        System.out.println(price);//error
        System.out.println(brand);//error
    }error:non static method show() cannot be referenced from a static context


     Mobile.show1(ob1);//give a object ref for the method to remove this error

take a look at this
// import java.io.*;
import java.lang.String;

class Mobile{
    String brand;int price;static String name="Phone";
    public void show(){
        //inside method
        System.out.println(brand);
        System.out.println(price);
        System.out.println(name);
    }

    public static void show1(Mobile ob){
        System.out.println("in static method");
        System.out.println(name);
        System.out.println(ob.price);
        System.out.println(ob.brand);
    }
}

public class Hello{
    public static void main(String a[]){
       Mobile  ob1 = new Mobile();
       ob1.brand = "Apple";
       ob1.price = 1500;
    
       
    
     Mobile.show1(ob1);
        
    }

}

__________________________________________________________________________________________
Encapsulation****
private int age;
Hello.java:12: error: age has private access in Human
        obj.age = 12;

public String getName(){
        return name;
}
System.out.println(obj.getName());

//set age
obj.setAge(30);
System.out.println(obj.getAge());

only way to access the data members through methods is called Encapsulation

__________________________________________________________________________________________
*******Getters and Setters*********
    public void setAge(int age){
        this.age = age;
    }

__________________________________________________________________________________________
*********this*******
local variable a is passed go ivariable age

    public void setAge(int a){
        age = a;
    }

        public void setAge(int age){
        age = age;//this should work right? but no
        it means age local variable is assigning to itself
    }

    do this

    public void setAge(int a, Human ob){
        
        ob.age = a;
    }

      obj.setAge(30, obj);
        System.out.println(obj.getAge());

    this refers to the current object
    this.age = age;

__________________________________________________________________________________________

**constructors*****
//String is object type so we get null before assigning

 public Human(){//defualt constuctor
        // You can write connections in constuctor
        //always change the instacne variables with methods or constructor best practice
        age = 13;
        name = "Rahul";
    }

     public Human(int a, String n){//parameterized constructor
        age = a;
        name = n;
    }
__________________________________________________________________________________________
this and super method**************

// import java.io.*;
import java.lang.String;

class A{

    public A(){
        System.out.println("in A");
    }

}class B extends A{
    public B(){
        System.out.println("in B");
    }
    // public B(int n){
    //     System.out.println("in B int");
    // }
}

public class Hello{
    public static void main(String a[]){
      B b = new B();
    }

}
//both constructors are called

//for this we get in A and in B int 
class B extends A{
    public B(){
        System.out.println("in B");
    }
    public B(int n){
        System.out.println("in B int");
    }
}//for   B b = new B(5);


//This code gives op as in A in int b

class A{

    public A(){
        System.out.println("in A");
    }
      public A(int n){
        System.out.println("in A int");
    }

}class B extends A{
    public B(){
        System.out.println("in B");
    }
    public B(int n){
        System.out.println("in B int");
    }
}
*Every constuctor in java has method which is invisible super() method
like
  public A(){
    super();
        System.out.println("in A");
    }
      public A(int n){
        super();
        System.out.println("in A int");
    }

*super means call the constuctor of the super class
*//this code gives op as in A int, in B int
// import java.io.*;
import java.lang.String;

class A{

    public A(){
        System.out.println("in A");
    }
      public A(int n){
        System.out.println("in A int");
    }

}class B extends A{
    public B(){
        System.out.println("in B");
    }
    public B(int n){
        super(n);
        System.out.println("in B int");
    }
}

public class Hello{
    public static void main(String a[]){
      B b = new B(5);
    }

}


*//for this we get op as in int A in B 

class A{

    public A(){
        System.out.println("in A");
    }
      public A(int n){
        System.out.println("in A int");
    }

}class B extends A{
    public B(){
        super(5);

        System.out.println("in B");
    }
    public B(int n){
        super(n);
        System.out.println("in B int");
    }
}

*what is super class for the biggest parent class?
every class extends Object class
meaning class A extends Object 
class B extends A multilevel inheritance


//this gives op as in A in B in intB
class B extends A{
    public B(){
      

        System.out.println("in B");
    }
    public B(int n){
        this();//will constructor of same class
        System.out.println("in B int");
    }
}

__________________________________________________________________________________________

naming conventions
class Calc
vairable marks
constants = PTE 
methods - showMyMarks()
Human()- constuctor

__________________________________________________________________________________________
**anonymous object
//stak will have object reference which is in heap
new A();//anonmous object 
    new A().show();
    new A().show();

__________________________________________________________________________________________
***inheritance
if in same directory we can access classes 
through object so imports are required
//write about class files here
when main java file has been ran we can get mainJavafile.class
if we create objects for the other classes in that file then JVM will create .class files for them

extends meaning is AdvcCalc 
we use multilevel inheritance every time
A, B as parents C child is not possible in java but in cpp
meaning
class C extends B, A
due to ambiguity problem//multiple inheritance

__________________________________________________________________________________________
**method overriding
class A{
    public void show(){
        System.out.println("in A show");
    }
}
class B extends A{
     public void show(){//override this method of class
        System.out.println("in B show");
    }
}
__________________________________________________________________________________________
***packages

use this in Calc.java=>package tools;
tools
 |
 |---Calc.js
 |---Calc.class 

 // import java.io.*;
import java.lang.String;
import tools.Calc;or tools.*;
public class Hello{
    public static void main(String a[]){
       Calc c = new Calc();
       System.out.println(c.add(1,2));
    }

}

System class belongs to java.lang
by default every java fies have java.lang.*;

__________________________________________________________________________________________
**access modifiers
private, public, private
if in same directory no problem for public
in different directories mention public for class and data members

private can be used in same class

  B b = new B();
b.c = 34;

        Hello.java:6: error: c has private access in B
        b.c = 34;
         ^
1 error

default is default

protected
cannot access data members outside the package 
but you can if you have subclass of that class 

__________________________________________________________________________________________
**polymorphism
compiler time or early binding->overloading
run time or late binding->overriding 
 // Laptop obj = new Laptop();
        // Computer obj = new Laptop();//is also correct because Laptop is technically a computer



////This is called dynamic method dispatch since in runtime the jvm decides which methpd to run
//and is only possible through inheritance
class A{
    public void show(){
        System.out.println("in A show");
    }
}
class B extends A{
    public void show(){
        System.out.println("in B show");
    }
}
class C extends B{
    public void show(){
        System.out.println("in B show");
    }
}

public class Hello{
    public static void main(String a[]){
        A obj = new A();//it should call B show right?
        obj.show();
        obj = new B();//new reference to B object
        //*********so A obj = new B() is overridden to B object address instead of A******
        obj.show();
        obj = new C();
        obj.show();

       
    }

}


__________________________________________________________________________________________
**final keyword
used with variables, method and classesa

variable--
  final int num = 8;//this becomes a constant
        num = 9;
        System.out.println(num);
Hello.java:22: error: cannot assign a value to final variable num
        num = 9;
        ^
1 error

class--

Hello.java:11: error: cannot inherit from final Calc
class AdvCalc extends Calc
                      ^
1 error


final class Calc{
    public void show(){
        System.out.println("in Calc show");
    }
    public void add(int a, int b){
        System.out.println(a+b);
    }
}
class AdvCalc extends Calc{
    public void r(){
        System.out.println("bla bla");
    }
}

method--
if we don't want anybody to overrider make the method final
like publi final void show

__________________________________________________________________________________________
**object Class

System.out.println(obj.toString());
System.out.println(obj);//both are same


class Laptop{
     String model;
     int price;
     public String toString(){
        return "Hey";
     }
}
public class Hello{
    public static void main(String a[]){
      Laptop obj = new Laptop();
      obj.model = "Lenovo Yoga";
      obj.price = 1000;
    
      System.out.println(obj);//returns hey
      System.out.println(obj.toString());//returns hey
    }

}

System.out.println(obj.equals(obj2));
 public boolean equals(Laptop that){
        if(this.model.equals(that.model) && this.price == that.price){
            return true;
        }else{ return false;}
     }
//use vscode or ide features to genearate from source action generate hashcode and equals

__________________________________________________________________________________________
***downcaasting and upcasting
  double d = 4.5;
        int i =(int) d;
        System.out.println(i);//typecasting

 A obj = (A)new B();
       obj.show1();//upcasting done automatically
    
   A obj = new B();//b obj refereid by a class
       obj.show1();
       B obj1=(B)obj;//downcast
       obj1.show2();

__________________________________________________________________________________________
**abstract

abstract class Car{
    public  abstract void drive();//abstact method must have abstact class
    public void playMusic(){//abstract class can have normal methods and abstact methods
        System.out.println("play music");
    }
}class WagonR extends Car{
    public void drive(){
        System.out.println("Driving...");
    }
}
public class Hello{
    public static void main(String a[]){
        Car ob = new WagonR();//WagonR is a concrete class
        //Car ob = new Car(); gives error bcoz abstact class cannot have objects
        ob.drive();
        ob.playMusic();
    }

}

//if declared in abstact class
public  abstract void drive();
//the child class should compulsorly define it other wise error
child class public void drive(){
    ...

}

//suppose there are many declared methods in abstact class
//you don't want to define them in wagonR class then you can make the wagonR also an abstact class
//then you cannot create object for wagonR so
create another class and extend it so that you can use this concrete class's object to run your methods

__________________________________________________________________________________________
**inner class

class A{
    int age;
    public void show(){
        System.out.println("in A show");
    }class B{
        public void config(){
            System.out.println("in config");
        }
    }
}
public class Hello{
    public static void main(String a[]){
      A obj = new A();
      obj.show();
      B obj1 = new B();
      obj1.config();

    }

}

obj1.config();
          ^
  symbol:   method config()
  location: variable obj1 of type B

//to resolve this use like this
class A{
    int age;
    public void show(){
        System.out.println("in A show");
    }class B{
        public void config(){
            System.out.println("in config");
        }
    }
}
public class Hello{
    public static void main(String a[]){
      A obj = new A();
      obj.show();
      A.B obj1 = obj.new B();//you will get A$B class file//since B is a non staic class
      obj1.config();



    }

}


//if class made static then you can use this
      A.B obj1 = new A.B();
class A{
    int age;
    public void show(){
        System.out.println("in A show");
    }
    static class B{
        public void config(){
            System.out.println("in config");
        }
    }
}//static can be only used for the inner class

__________________________________________________________________________________________
**anonymous inner class
//overrides in A show method
public class Hello{
    public static void main(String a[]){
      A obj = new A(){//anonymous inner class because this resides inside Hello class
        public void show(){
        System.out.println("in B show");
    }
      };
      obj.show();

    }

}

__________________________________________________________________________________________
abstract and anonymous inner class**************
abstract class A{
    
    abstract public void show();

}
public class Hello{
    public static void main(String a[]){
     A ab = new A(){//we are creating object of anyonymous inner class
      public void show(){
        System.out.println("in Hello A show");
      }
     };
     ab.show();

    }

}

__________________________________________________________________________________________
**interfaces

interface A{
  int age=22;String area="ss";  //all variables inside interface are final and static
 void show();//by default every thing is public abstract
  void config();

}
class B implements A{
  //must and should define the interface methods
  //if not this class becomes abstract class
  public void show(){
    System.out.println("in show");
  }
  public void config(){
    System.out.println("in config");
  }
}
public class Hello{
    public static void main(String a[]){
      A obj = new B();
      obj.show();
      System.out.println(obj.age);
    }

}//one class can implement multiple interfaces
// interface Y extends x


What is the need of interfaces
interface computer{
    public void code();
}
class Laptop implements Computer{
    public void show(){
        prinltn("code ");
    }
}
class Desktop implements Computer{
    public void show(){
        prinltn("code faster");
    }
}

class Developer {
    public void devApp(Computer ob){
        ob.code();
    }
}

main{
    Computer desk = new Desktop();
    Developer navin  = new Developer();
    naving.devApp(desk);
}

__________________________________________________________________________________________
**enum//named constants


//Status is a class
enum Status{
    Running, Failed, Pending, Success;//named constants

}

public class Hello{
    public static void main(String a[]){
        Status s = Status.Running;
        System.out.println(s.ordinal());//0 
        Status [] ss= Status.values();
        for(Status si:ss){
        System.out.println(si+" "+si.ordinal());

        }

        switch(s){
            case Running: System.out.println("All good");
            break;
        }

        // Status s = Status.Pending;
        if(s==Status.Running){
            System.out.println("all good");
        }else if (s==Status.Failed){
            System.out.println("Try again");
        }else if(s==Status.Pending){
            System.out.println("Please Wait");
        }

    }

}//you cannot extend with any other class

System.out.println(s.getClass().getSuperclass());
class java.lang.Enum//enum extends Enum



//Status is a class
enum Laptop{
    Macbook(2000), XPS(2200), Surface(1500), ThinkPad(1800), Lenovo;
    private int price;
    private Laptop(){
        price = 500;//default 
    }
    private  Laptop(int price){
        this.price = price;
        System.out.println("in Laptop "+this.name());
    }//because objects are created in the same class we need private constructors


    public int getPrice() {
        return price;
    }


    public void setPrice(int price) {
        this.price = price;
    }
}

public class Hello{
    public static void main(String a[]){
      Laptop lap = Laptop.Macbook;
      System.out.println(lap+" "+lap.getPrice());

      for(Laptop lapp:Laptop.values()){
        System.out.println(lapp+" "+lapp.getPrice());
      }

    }
 

}



__________________________________________________________________________________________
**annotations


class A{
    public void shoTheDAtaWhichBelongsToThisClass(){
        System.out.println("in A show");
    }
}class B extends A{
    @Override 
    //@depricrated do not use this class
    public void shoTheDAtaWhichBelongsToThisClass(){
        System.out.println("in B show");
    }
}
public class Hello{
    public static void main(String a[]){
        B obj = new B();
        obj.shoTheDAtaWhichBelongsToThisClass();
    }
 

}

__________________________________________________________________________________________
**lambda expression
@FunctionalInterface//single abstract methods contains
interface A{
    void show();
}

//behind the scene we have A obj = new A();
but this is the code
@FunctionalInterface
interface A{
    void show();
}
//syntactical sugar
public class Hello{
    public static void main(String a[]){
       A obj = ()->{
        {
            System.out.println("in Hello in show");//you can also remove the braces
        }
       };
       obj.show();
    }
 

}


@FunctionalInterface
interface A{
    void show(int i);
   // void show();//is not accepted because multiple non overriding abstract methods found in interface A error occurs
}

public class Hello{
    public static void main(String a[]){
       A obj = (i)->{
        {
            System.out.println("in Hello in show "+i);
        }
       };
       //or A obj =i -> prinltn(i)
       obj.show(5);
    }
 

}



A obj = ( i, j)->i+j;//short hand for

   A obj = new A(){
        
            public int add(int i, int j){
                return i+j;
            }
        
       };
       int result = obj.add(5, 4);
       System.out.println(result);
    
__________________________________________________________________________________________
**Types of interfaces
normal--->two or more methods
Functional or single abstact method-->single method
marker--> no methods//used for serialization for objects

__________________________________________________________________________________________
**Exceptions
Types of Errors
1.Compile time//eg:Println
2.runtime//to open a file but the file is not there
3.logical//2+2 but returns 5 because you need to do testing

  int i = 9;
       
        try{
             int j = 9/0;
            System.out.println(j);
        }catch(ArithmeticException e){
            System.out.println("Cannot divide by zero");
        }catch(ArrayIndexOutof){}
        catch(Exception e){
            
        }

__________________________________________________________________________________________
Hierarchy**

Object
Throwable----------
                   |
                   |
            ----------------              |----(CheckedException)SqlException--IoEXcption,ClassNotFoundException
            |              |              |
            |              |--Exception-----|-----(UncheckedException)Runtime----Arithmetic, ArrayIndex, NullPointer
            |
        ----------------------
        |       |       |     |
        |       |       |     |
    ThreadDeath VirtualMachineE,
                OutofMemorIOError

__________________________________________________________________________________________
**throw and throws

 int i =20;
      int j =0;
      try{
        j = 18/i;//throw exception
        if(j==0) throw new ArithmeticException("I don't want to print zero");

      }catch(ArithmeticException e){
        System.out.println("blab bla bla"+e);
      }


class NavinException extends Exception//or RunTimeException{
    public  NavinException(String string){
        super(string);
    }
}

public class Hello{
    public static void main(String a[]){
      int i =20;
      int j =0;
      try{
        j = 18/i;//throw exception
        if(j==0) throw new NavinException("I don't want to print zero");

      }catch(NavinException e){
        j= 18/1;
        System.out.println("blab bla bla"+e);
      }
    }

}

**throws

c(){//handle exception
    try{
         d();
         e();
    }
    catch()
   
}
d() throws Exception{//ducking the exception

}
e() throws Exception{

}

public show() throws ClassNotFoundException{
    Class.forName("Calc");
}//do not use throws for main
e.printStackTrace means show the hierarchy of calling methods

__________________________________________________________________________________________
**Input from The user
out is created as static variable  in System class
and println is a method of PrintStream
out is the object for PrintStream


import java.io.IOException;
public class Hello{
    public static void main(String a[])throws IOException{
        System.out.println("Enter a nubmer");
        int num = System.in.read();//gives ascii number
        System.out.println(num);
        System.out.println(num-40);
    }
}

//for large numbers
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
public class Hello{
    public static void main(String a[])throws IOException{
       InputStreamReader in = new InputStreamReader(System.in);
       BufferedReader bf = new BufferedReader(in);//needs object of inputStreamREader
       int num =Integer.parseInt(bf.readLine());
       System.out.println(num);
       bf.close();

    }
}

import java.util.Scanner;
public class Hello{
    public static void main(String a[]){
    System.out.println("Enter a number");
     Scanner sc = new Scanner(System.in);
     int num=sc.nextInt();
     System.out.println(num);
        
    }
}

__________________________________________________________________________________________
**try with resources



































